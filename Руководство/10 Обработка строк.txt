Весь приходящий с сервера текст разбивается на строки, которые затем поочередно передаются функции ОбработатьСтроку для преобразования, совершения автоматических действий (так называемые триггеры) и вывода на экран. Во избежание разрыва поступающих с сервера строк настоятельно рекомендуется включить в маде завершение статусной строки последовательностью IAC GA. В Былинах это делается с помощью команды "реж автозавер", а в Хьёрварде командой "реж GA".

Функция ОбработатьСтроку возвращает команды, которые нужно выполнить или null, если никаких действий не требуется:

public override string ОбработатьСтроку(Строка строка, bool статуснаяСтрока)
{
	string значение = строка.ToString();
	if (значение == "Минул час.")
	{
		ЭлементВывода.Добавить(new Строка("----- МИНУЛ ЧАС -----", 0x09));
		return "петь;ик";
	}
	return base.ОбработатьСтроку(строка, статуснаяСтрока);
}

Теперь вместо строки "Минул час." будет выводиться "----- МИНУЛ ЧАС -----" и автоматически выполняться команды "петь;ик".

Для того чтобы блокировать вывод строки на экран, просто прервите функцию, как это показано в следующем примере:

public override string ОбработатьСтроку(Строка строка, bool статуснаяСтрока)
{
	string значение = строка.ToString();
	...
	if (значение.StartsWith("Ледяной щит"))
		return null;
	if (значение.StartsWith("Воздушный щит"))
		return null;
	...
	return base.ОбработатьСтроку(строка, статуснаяСтрока);
}

Изменить цвет сроки можно с помощью функции Перекрасить:

public override string ОбработатьСтроку(Строка строка, bool статуснаяСтрока)
{
	string значение = строка.ToString();
	...
	if (значение.StartsWith("Вам лучше встать"))
	{
		строка.Перекрасить(0x9F);
		ЭлементВывода.Добавить(строка);
		return null;
	}
	...
	return base.ОбработатьСтроку(строка, статуснаяСтрока);
}

То есть, строка, которая начинается на "Вам лучше встать" выводится белым цветом на красном фоне (здесь для выбора нужного цвета удобно использовать команду "#цвета"). Если Вам нужно подсветить не всю строку, а только ее фрагмент, то это можно сделать так:

public override string ОбработатьСтроку(Строка строка, bool статуснаяСтрока)
{
	строка.Перекрасить("с севера", 0x0A);
	строка.Перекрасить("с юга", 0x0A);
	строка.Перекрасить("с запада", 0x0A);
	строка.Перекрасить("с востока", 0x0A);
	строка.Перекрасить("сверху", 0x0A);
	строка.Перекрасить("снизу", 0x0A);
	...
	return base.ОбработатьСтроку(строка, статуснаяСтрока);
}

Теперь все эти подстроки будут окрашены в зеленый цвет. Для того чтобы изменить фрагмент строки используйте метод Заменить, причем можно заменять подстроки как с сохранением цвета, так и с перекраской в другой цвет:

public override string ОбработатьСтроку(Строка строка, bool статуснаяСтрока)
{
	строка.Заменить("поплелись", "направили свой путь");
	строка.Заменить("Вас", "ВАС", 0x0B);
	...
	return base.ОбработатьСтроку(строка, статуснаяСтрока);
}

Здесь слово "поплелись" заменяется на "направили свой путь", а слово "Вас" заменяется на "ВАС" и окрашивается в желтый цвет.

Флаг статуснаяСтрока сигнализирует о том, что эта строка является промптом. В качестве демонстрации создадим триггеры, срабатывающие при вступлении персонажа в бой и при прекращении сражения.

bool вБою = false;

public override string ОбработатьСтроку(Строка строка, bool статуснаяСтрока)
{
	...
	Match match;
	string значение = строка.ToString();
	match = Regex.Match(значение, @"\[.+:.+\] >$");
	if (match.Success && статуснаяСтрока)
	{
		ЭлементВывода.Добавить(строка);
		if (!вБою)
		{
			ЭлементВывода.Добавить("----- Персонаж вступил в бой! -----");
			вБою = true;
		}
		return null;
	}
	match = Regex.Match(значение, @">$");
	if (match.Success && статуснаяСтрока)
	{
		ЭлементВывода.Добавить(строка);
		if (вБою)
		{
			ЭлементВывода.Добавить("----- Персонаж прекратил сражаться! -----");
			вБою = false;
		}
		return null;
	}
	if (значение == "   Чего Ваша душа желает ?" && статуснаяСтрока) // при гибели персонажа
	{
		ЭлементВывода.Добавить(строка);
		if (вБою)
		{
			ЭлементВывода.Добавить("----- Персонаж прекратил сражаться! -----");
			вБою = false;
		}
		return null;
	}
	...
	return base.ОбработатьСтроку(строка, статуснаяСтрока);
}

Особенностью клиента является то, что все сообщения, выдаваемые классом Соединение, передаются тем же путем, что и обычный текст, поступающий с сервера, а потому на них можно ставить триггеры, как это показано в следующем примере:

public override string ОбработатьСтроку(Строка строка, bool статуснаяСтрока)
{
	...
	Match match;
	string значение = строка.ToString();
	match = Regex.Match(значение, @"^### (Версия MCCP|Коэффициент сжатия): (.+)\.");
	if (match.Success)
	{
		ЭлементВывода.Добавить(строка);
		return match.Result("эмо : $1 = $2");
	}
	if (значение == "### Сжатие отсутствует.")
	{
		ЭлементВывода.Добавить(строка);
		return "эмо : Сжатие отсутствует";
	}
	...
	return base.ОбработатьСтроку(строка, статуснаяСтрока);
}

Теперь информация о соединении, получаемая с помощью команды #информация, не только выводится на экран, но и отправляется в мад.

Следует помнить, что некоторые из сообщений, выдаваемых классом Соединение, являются статусными. Вот полный их список:

### Соединение утеряно.
### Соединение разорвано пользователем.
### Не удалось установить соединение.
### Соединение успешно установлено.
### Соединение с прокси-сервером успешно установлено.

Остальные сообщения не являются статусными.

Воспользуемся этой информацией для того, чтобы установить в false переменную вБою при утере соединения:

public override string ОбработатьСтроку(Строка строка, bool статуснаяСтрока)
{
	...
	Match match;
	string значение = строка.ToString();
	if (значение.StartsWith("### ") && статуснаяСтрока) // при разрыве связи
	{
		ЭлементВывода.Добавить(строка);
		if (вБою)
		{
			ЭлементВывода.Добавить("----- Персонаж прекратил сражаться! -----");
			вБою = false;
		}
		return null;
	}
	...
	return base.ОбработатьСтроку(строка, статуснаяСтрока);
}
